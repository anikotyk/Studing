Код виконання цієї лабораторної знаходиться за посиланням:
https://github.com/anikotyk/Unity/tree/main/CubeRunner/Assets/Scripts

Було використано 3 патерни:
1. Патерн створення - Singleton. Використан у классах AdsController, AudioController, GameController, PlayerController.
По-перше, ці класи мають існувати на сцені в єдиному екземплярі, для уникнення помилок.
По-друге, до до них часто звертаються ігрові об'єкти. До використання цього патерну, звертання до цих класів відбувалося за допомогою функції GameObject.FindObjectOfType, що займало більше часу ніж звернення через статичний екземпляр класу.

Тобто використання цього патерну пришвидшило роботу програми. Та гарантує уникнення помилок, якщо на сцені раптово створиться другий екзмепляр класу.

2. Поведінковий патерн - Observer. Використан у классах AdsController, AudioController, GameController, PlayerController, PlayerMovement, SpawnObstacles. Коли відбуваються якісь зміни, то суб'єкт надсилає сповіщення про них, а спостерігачі отримують сповіщення. Наприклад, коли PlayerController бачить, що здоров'я ігрока дорівнює 0, то надсилає сповіщення про програш. Його отримують підписані об'єкти, тобто наприклад AudioController, котрий вмикає звук програшу, і PlayerMovement котрий зупиняє рух ігрока. 
Це надає гибкість розробки. Тобто, раніше, при програші треба було звертатися напряму до класів AudioController, GameController, PlayerMovement. І якщо з'являвся новий клас, то додавати звернення до нього. Таким чином можно було щось загубити.
Але зараз, єдине що треба зробити, це викликати сповіщення LevelLoose, і усі об'єкти котрі мають щось робити при програші його отримують і викликають відповідні функції.

3. Структурний патерн - Flyweight. Це розділення логіки гри на окремі компоненти. Тобто, замість одного классу котрий усім управляє, ми створили окремі AdsController, AudioController, GameController, AnimController, SpawnObstacles. Також розділили управління ігроком на окремі компоненти - PlayerController (відповідає за контроль здоров'я та зовнішні зміни) та PlayerMovement (відповідає за рух та зупинку ігрока).
По-перше, при використанні цього патерну легше розуміти код. 
По-друге, легше щось змінити. Тобто, якщо меня буде потрібно змінити тип руху ігрока, я зміню лише PlayerMovement, а усі інші компоненти залишаться незмінними.
